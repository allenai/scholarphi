import { PDFDocumentProxy } from "pdfjs-dist";
import React from "react";
import DefinitionPreview from "./DefinitionPreview";
import Drawer, { DrawerMode } from "./Drawer";
import FindBar, { FindMode, FindQuery } from "./FindBar";
import * as selectors from "./selectors";
import { divDimensionStyles, matchingSymbols } from "./selectors";
import { Entities, Pages, PaperId, Papers, UserLibrary } from "./state";
import {
  BoundingBox,
  EntityUpdateData,
  isSentence,
  Sentence,
  Symbol,
} from "./types/api";
import { PDFViewer, PDFViewerApplication } from "./types/pdfjs-viewer";
import * as uiUtils from "./utils/ui";

interface Props {
  pdfViewerApplication: PDFViewerApplication;
  pdfViewer: PDFViewer;
  pdfDocument: PDFDocumentProxy | null;
  pages: Pages | null;
  paperId?: PaperId;
  papers: Papers | null;
  entities: Entities | null;
  userLibrary: UserLibrary | null;
  selectedEntityId: string | null;
  entityEditingEnabled: boolean;
  isFindActive: boolean;
  findActivationTimeMs: number | null;
  findMode: FindMode;
  findQuery: FindQuery;
  findMatchIndex: number | null;
  findMatchCount: number | null;
  drawerMode: DrawerMode;
  handleCloseFindBar: () => void;
  handleCloseDrawer: () => void;
  handleChangeMatchIndex: (matchIndex: number | null) => void;
  handleChangeMatchCount: (matchCount: number | null) => void;
  handleChangeQuery: (query: FindQuery | null) => void;
  handleDeselectSelection: () => void;
  handleSelectEntity: (id: string) => void;
  handleScrollSymbolIntoView: () => void;
  handleAddPaperToLibrary: (paperId: string, paperTitle: string) => void;
  handleUpdateEntity: (entity: EntityUpdateData) => Promise<boolean>;
  handleDeleteEntity: (id: string) => Promise<boolean>;
}

interface State {
  /**
   * Time of the last update to the viewport of the viewer. Set this variable to a new value
   * (e.g., using using Date.now()) to trigger components of the overlay to re-render that
   * depend on the scroll position of the viewer (e.g., the 'DefinitionPreview').
   */
  viewerViewportUpdateTimeMs: number;
}

/**
 * Determine whether a click event targets a selectable element.
 */
function isClickEventInsideSelectable(event: MouseEvent) {
  return (
    event.target instanceof HTMLDivElement &&
    event.target.classList.contains("scholar-reader-annotation-span")
  );
}

/**
 * An overlay on top of the PDF Viewer containing widgets to be shown on top of the viewer, and
 * event handlers that trigger state changes based on click and keyboard
 * events. This overlay currently operates by adding event handlers to the container of
 * the PDF viewer generated by pdf.js. The component does not make any new DOM elements.
 *
 * In a past implementation, this component added a transparent overlay 'div' element on top of
 * the PDF viewer. That implementation was abandoned because the overlay intercepted click and
 * keyboard events that were meant for the page or for annotations on the page. In the current
 * implementation, clicks on the page or annotations will be processed by the page or annotation
 * *and* processed by this overlay, as in this overlay, event handlers are attached to a
 * parent element of all pages and annotations.
 */
class ViewerOverlay extends React.PureComponent<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      viewerViewportUpdateTimeMs: Date.now(),
    };
    this.onClick = this.onClick.bind(this);
    this.onKeyUp = this.onKeyUp.bind(this);
    this.onScroll = this.onScroll.bind(this);
  }

  componentDidMount() {
    this.addEventListenersToViewer(this.props.pdfViewer);
  }

  componentDidUpdate(prevProps: Props) {
    if (prevProps.pdfViewer !== this.props.pdfViewer) {
      this.removeEventListenersForViewer(prevProps.pdfViewer);
      this.addEventListenersToViewer(this.props.pdfViewer);
    }
  }

  componentWillUnmount() {
    this.removeEventListenersForViewer(this.props.pdfViewer);
  }

  addEventListenersToViewer(pdfViewer: PDFViewer) {
    pdfViewer.container.addEventListener("click", this.onClick);
    pdfViewer.container.addEventListener("keyup", this.onKeyUp);
    pdfViewer.container.addEventListener("scroll", this.onScroll);
  }

  removeEventListenersForViewer(pdfViewer: PDFViewer) {
    pdfViewer.container.removeEventListener("click", this.onClick);
    pdfViewer.container.removeEventListener("keyup", this.onKeyUp);
    pdfViewer.container.removeEventListener("scroll", this.onScroll);
  }

  onClick(event: MouseEvent) {
    if (!isClickEventInsideSelectable(event)) {
      this.props.handleDeselectSelection();
    }
  }

  onKeyUp(event: KeyboardEvent) {
    if (uiUtils.isKeypressEscape(event)) {
      this.props.handleDeselectSelection();
    }
  }

  onScroll() {
    this.setState({
      viewerViewportUpdateTimeMs: Date.now(),
    });
  }

  getDefinitionSentenceAndSymbol() {
    let definitionSymbol: Symbol | null = null,
      definitionSentence: Sentence | null = null;

    const { selectedEntityId, entities } = this.props;

    if (
      selectedEntityId === null ||
      entities === null ||
      selectors.selectedEntityType(selectedEntityId, entities) !== "symbol"
    ) {
      return { definitionSentence, symbol: definitionSymbol };
    }

    const matchingSymbolIds = matchingSymbols(selectedEntityId, entities, [
      { key: "exact-match", active: true },
    ]);
    const firstMatchingSymbolId =
      matchingSymbolIds.length > 0 ? matchingSymbolIds[0] : selectedEntityId;
    definitionSymbol = entities.byId[firstMatchingSymbolId] as Symbol;

    const sentenceId = definitionSymbol.relationships.sentence.id;
    if (sentenceId !== null && entities.byId[sentenceId] !== undefined) {
      const sentence = entities.byId[sentenceId];
      if (isSentence(sentence)) {
        definitionSentence = sentence;
      }
    }
    return { definitionSentence, symbol: definitionSymbol };
  }

  areBoundingBoxesVisible(boundingBoxes: BoundingBox[]) {
    const { pdfViewer, pages } = this.props;

    let visible = false;
    for (const box of boundingBoxes) {
      /*
       * If the page for this box has not yet been loaded into memory, then it is has not yet
       * been rendered, and therefore is not visible.
       */
      if (pages === null) {
        continue;
      }
      const page = pages[box.page + 1];
      if (page === undefined || page === null) {
        continue;
      }

      const {
        scrollLeft,
        scrollTop,
        clientWidth,
        clientHeight,
      } = pdfViewer.container;
      const boxRelativeToPage = divDimensionStyles(page.view, box);

      const boxLeft = page.view.div.offsetLeft + boxRelativeToPage.left;
      const boxRight = boxLeft + boxRelativeToPage.width;
      const boxTop = page.view.div.offsetTop + boxRelativeToPage.top;
      const boxBottom = boxTop + boxRelativeToPage.height;

      /*
       * If the box is not in the scrolled region of the viewer, then it is not visible.
       */
      if (
        boxRight < scrollLeft ||
        boxLeft > scrollLeft + clientWidth ||
        boxTop > scrollTop + clientHeight ||
        boxBottom < scrollTop
      ) {
        continue;
      }

      /*
       * If all of the checks above failed, the box is visible in the viewer.
       */
      visible = true;
      break;
    }

    return visible;
  }

  render() {
    const {
      symbol: definitionSymbol,
      definitionSentence,
    } = this.getDefinitionSentenceAndSymbol();

    /*
     * Show the definition preview if the definition is currently off-screen.
     */
    let renderDefinitionPreview = false;
    if (definitionSymbol !== null) {
      if (
        definitionSentence !== null &&
        !this.areBoundingBoxesVisible(
          definitionSentence.attributes.bounding_boxes
        )
      ) {
        renderDefinitionPreview = true;
      } else if (
        !this.areBoundingBoxesVisible(
          definitionSymbol.attributes.bounding_boxes
        )
      ) {
        renderDefinitionPreview = true;
      }
    }

    return (
      <>
        {this.props.isFindActive && this.props.findActivationTimeMs !== null ? (
          <FindBar
            /*
             * Set the key for the widget to the time that the find event was activated
             * (i.e., when 'Ctrl+F' was typed). This regenerates the widgets whenever
             * a new 'find' action is started, which will select and focus the text
             * in the search widget. See why we use key to regenerate component here:
             * https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key
             */
            key={this.props.findActivationTimeMs}
            matchCount={this.props.findMatchCount}
            matchIndex={this.props.findMatchIndex}
            mode={this.props.findMode}
            pdfViewerApplication={this.props.pdfViewerApplication}
            query={this.props.findQuery}
            handleChangeMatchCount={this.props.handleChangeMatchCount}
            handleChangeMatchIndex={this.props.handleChangeMatchIndex}
            handleChangeQuery={this.props.handleChangeQuery}
            handleClose={this.props.handleCloseFindBar}
          />
        ) : null}
        <Drawer
          paperId={this.props.paperId}
          pdfViewer={this.props.pdfViewer}
          pdfDocument={this.props.pdfDocument}
          mode={this.props.drawerMode}
          userLibrary={this.props.userLibrary}
          papers={this.props.papers}
          entities={this.props.entities}
          selectedEntityId={this.props.selectedEntityId}
          entityEditingEnabled={this.props.entityEditingEnabled}
          handleSelectSymbol={this.props.handleSelectEntity}
          handleScrollSymbolIntoView={this.props.handleScrollSymbolIntoView}
          handleClose={this.props.handleCloseDrawer}
          handleAddPaperToLibrary={this.props.handleAddPaperToLibrary}
          handleUpdateEntity={this.props.handleUpdateEntity}
          handleDeleteEntity={this.props.handleDeleteEntity}
        />
        {renderDefinitionPreview &&
        this.props.pdfDocument !== null &&
        definitionSymbol !== null ? (
          <DefinitionPreview
            pdfDocument={this.props.pdfDocument}
            symbol={definitionSymbol}
            sentence={definitionSentence}
          />
        ) : null}
      </>
    );
  }
}

export default ViewerOverlay;
